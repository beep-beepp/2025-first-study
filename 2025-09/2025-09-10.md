지원의 주저리 : 뇌과학적으로 아웃풋이 중요하다. 일단 보지 않고 내뱉는 버릇을 들이자.

### 종현

- flutterflow, 프로젝트 && 창업 공유
# 0. 나의 정보

- Nest, Supabase, Google cloud 그리고 flutterflow를 통한 구현
    - 내부 테스트 배포까지 성공하였고 기능들이 버그있게 동작하는 정도로 구현
        - https://www.figma.com/design/pCnhbGGnjv8jWnd1sKs4VF/DearLink%EC%99%80%EC%9D%B4%EC%96%B4%ED%94%84%EB%A0%88%EC%9E%84-%EB%94%94%EC%9E%90%EC%9D%B8?node-id=1-2&t=EZgTZ6P9Et2Yohut-1
- [플루터 플로우](https://www.flutterflow.io/)는 노코드는 아니고 플루터의 로우코드 툴로서 유명함
    - 플루터경험 0, 모바일 앱 경험 0 에서 시작함
    - 비쌈 월에 70달러 주고 썼던것 같음
- 서버는 익숙한 Nest를 사용했고 Supabase, Google cloud는 플루터 플로우에서 지원/연동을 해주어서 사용
- 프로젝트 작업기간 약 3달

# 1.  노코드 툴을 하며 느낀점

결론: 플루터를 배우고 ai agent를 쓰겠다.

1. 너무 재미있게 사용했다. 이렇게 간단하게 이런 퀄리티가 나오다니
2. 문서가 없을때 디버그나 구현이 쉽지않다.
    1. 범용적으로 잘 알려진 flutterflow인데도 이상한 버그가 많다. ex) android clientId 입력하는 곳이 없음
    2. 코드에서는 딸깍으로 고칠수 있는데
    3. 코드를 들여다 보게 됨
3. ai agent를 알기 전: 꾸준히 쓸만 하겠다 생각이 있었음, 그 후: flutter를 살짝배워서 ai agent를 붙이는게 좋겠다.
    1. 진짜 간단한 프로젝트면 재사용 의사 있음 페이지 한 10장까지? 로직 안복잡한 정도

# 2. 이번 프로젝트를 하며 느낀점

1. 단계를 잘게 쪼개자.
    
    예를 들면
    
    1. 우선 배포
    2. 로컬 로그인 구현
    3. Oauth로그인 구현
2. 디자이너 있어도 문제 없어도 문제
    - 빠른 반응을 살펴보고 싶었는데 디자인이 형편없었고 사람구하기가 힘들었다. 힘겹게 찾아서 했지만 그에 맞는 요구를 맞춰 구현하는게 힘들었다.
        - 개발자와 디자이너의 의견차이 (왜 이 디자인이 필요하지 구현 어려운데)
    - 다음에는 디자인 퀄리티를 포기할듯

# 3. 창업을 하며 느낀점

1. 같이 창업 할사람의 장점보다는 문제가 될수 있는 점을 살피자.
    1. 다음에 다시 한다면 개발을 아는 사람이나 개발자랑 같이 일해봤던 사람이랑 할듯
2. 각자 잘하는거하자.
### 석희

- 다형성
- solid
- 지원님이 핸드폰 보는거 단호히(?) 거절하심
- 하지만 지키기가 힘들다. 아직도 고민이 많다.

- 지원님 인터페이스 분리가 중요한 느낌을 느꼈다.
    - crud interface를 몰았다 패착을 보았다.
- 최소한으로 지킬건 지키자

### 지원

- JMM (Java Memory Model)
1. 왜 필요한가?
    1. 자바는 멀티 스레드 프로그래밍을 많이 한다.
    2. 하지만 실제로 CPU와 메모리 사이에는 캐시, 레지스터, 최적화가 존재해서 스레드마다 다른 값을 볼 수 있다.
    3. 그래서 스레드간 consistency 를 보장하는 규칙이 필요하다. 이것이 JMM이다.
2. 주요 개념
    1. visibility
        - 한 스레드가 변경한 값이 다른 스레드에서 보이는 성질
        - ex. 캐시에만 쓰고 메모리에 반영하지 않으면 다른 스레드에서 변경한 값을 못 본다.
    2. atomicity
        - 연산이 쪼개지지 않고 한 번에 실행되는 성질
        - ex. count++는 내부적으로 읽기-더하기-쓰기 3단계라 원자성이 보장되지 않는다.
    3. ordering
        - 컴파일러나 CPU가 최적화를 위해 코드 순서를 바꿔도, 프로그램의 의미가 깨지지 않게 보장하는 성질
        - ex. flag = true; data = 1; 이 실제 실행에서는 순서가 바뀔 수 있다.
3. 주요 키워드
    1. volatile
        - 해당 변수는 항상 메모리에서 읽고 쓴다.
        - 가시성 + 순서성 보장
        - 하지만 i++ 같은 복합 연산의 원자성은 보장하지 않는다.
        - 순서성이 보장된다는 뜻이 정확히 뭘까?
          - JMM에서 volatile 변수애 대한 읽기/쓰기 앞뒤 명령어 재배치를 금지한다.
          - volatile write 앞에 있는 모든 연산은 실제로도 먼저 실행되로 flush된 다음 volatile 쓰기가 일어난다.
          - volatile read 뒤에 있는 모든 연산은 실제로도 그 이후에 실행된다. 
          - 즉, volatile이 메모리 장벽 역할을 해서 코드 순서를 의도한대로 유지시켜준다.
    2. synchronized, Lock
       - 임계영역을 한 번에 한 스레드만 실행할 수 있다.
       - 락 해제시 메모리에 즉시 반영하고, 다른 스레드가 락 획득시 최신 값을 읽는다.
       - 가시성, 원자성, 순서성 모두 보장한다.
    3. happens-before  
       - "한 작업의 결과가 다른 작업에서 반드시 보인다."는 순서보장 관계를 말한다.
       - A happens-before B : A가 끝난 후에 모든 결과가 B에서 반드시 관측된다.
       - 두 작업의 실행 순서를 보장하는 JMM의 핵심 규칙
         - ex. 같은 스레드 안의 코드 순서 -> happens-before
         - unlock -> 그 다음 lock은 happens-before
         - volatile write -> 그 다음 read는 happens-before
4. 예시
```jsx
   class Example {
     private volatile boolean ready = false;
     private int data = 0;
     
     public void writer() {
       data = 42;
       ready = true;
     }
     
     public void reader() {
       if (ready) {
         System.out.println(data);
       }
     }
   }
```

5. 정리
JMM이란 멀티 스레드 환경에서 스레드가 메모리를 어떻게 읽고 쓰는지 정의하는 규칙으로, 
Visibility, Atomicity, Ordering 을 보장하기 위해 volatile, synchronized, happens-before 관계를 제공한다.


### 한의희
아파서 늦참. 
할려고 했던거 발표안했으니까 최대한 이쁘게 적어봄


# Java Memory Model (JMM)

### 1. 개념
- JMM은 멀티스레드에서 **원자성(Atomicity), 가시성(Visibility), 순서성(Ordering)**을 정의한 **추상적 명세**이다.
- JMM을 구체적으로 보장하기 위해 **8가지 규칙**이 있으며, 이것을 **happens-before 추상 규칙**이라고 한다.
- happens-before 관계를 실제 코드에서 구현하는 키워드들이 `synchronized`, `volatile` 등이다.
- 이 규칙이 JVM 내부에서 동작하기 때문에 우리가 별다른 순서를 지정하지 않아도 **정상 동작**한다.

---

### 2. 알아야 하는 키워드
- **volatile**
    - 가시성만 보장
    - 순서성은 일부 보장
    - 원자성은 보장하지 않음

- **synchronized**
    - 가시성, 원자성, 순서성을 **전부 보장**

- **Atomic~ (AtomicInteger 등)**
    - 가시성과 원자성 보장
    - 순서성은 일부만 보장

---

### 3. 개발할 때, 언제 씀?
   - volatile은 가시성이 필요한 상태 플래그 변수(스레드 종료, 배치 중단 등)에 자주 쓰인다.
   ```jsx
     class VolatileExample {
        private volatile boolean running = true; // 상태 플래그
    
        public void run() {
            while (running) {
                // do something
            }
        }
    
        public void stop() {
            running = false; // 다른 스레드에서 즉시 반영됨
        }
    }   
  ```
   - synchronized는 공유 자원에 동시에 접근하지 못하게 객체 단위로 모니터 락을 걸어, 
     은행 출금처럼 반드시 하나의 스레드만 안전하게 실행해야 하는 임계 구역을 보호할 때 사용한다.
   
   ```jsx
   class BankAccount {
    private int balance = 1000;

    public synchronized void withdraw(int amount) {
        if (balance >= amount) {
            balance -= amount; // 원자적 보장
        }
    }

    public synchronized int getBalance() {
        return balance; // 가시성 + 순서성 보장
    }
}
  ```
   - Atomic~ 클래스는 내부적으로 volatile 변수와 CAS(Compare-And-Swap) 알고리즘을 사용하기 때문에, 
     lock 없이도 가시성과 원자성이 필요한 복합 연산을 안전하게 수행할 수 있다.
```jsx
import java.util.concurrent.atomic.AtomicInteger;

class AtomicExample {
  private AtomicInteger counter = new AtomicInteger(0);

  public void increment() {
    counter.incrementAndGet(); // 원자적 증가
  }

  public int get() {
    return counter.get(); // volatile 기반 가시성 보장
  }
}

  ```

### 4. 헷갈리지 말기
- JMM 보장은 하나의 JVM 안에서만 동작한다. 
- 즉, **멀티 서버** 환경에서는 JMM만으로 동시성을 제어할 수 없다. 
   


