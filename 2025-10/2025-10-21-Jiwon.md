### 지원

# CMS GC

## 1. 목적
Java 5에 도입된 Low Pause Time 중심의 GC이다.

**CMS(Concurrent Mark-Sweep)** 는 이름 그대로
- **Concurrent** : 애플리케이션 스레드가 실행되는 동안 일부 GC 단계가 병행적으로 수행된다.
- **Mark-Sweep** : 살아있는 객체를 표시하고(Mark), 죽은 객체를 쓸어내는(Sweep) 알고리즘을 사용한다.

즉, STW 시간을 최소화해서 끊김 없는 서비스를 목표로 한 GC이다.


## 2. 왜 나왔는가?

Parallel GC는 Throughput은 높지만, STW 시간이 길다.
<br>실시간 응답이 중요한 서비스(검색, 결제 등)는 수 초의 멈춤을 감당하기 어려웠다.
<br>
<br>그래서 "빠르게 끝내기(Throughput)" -> "끊김 없이 작동하기(Low Pause)"에 초점을 맞춘 CMS가 등장했다.
즉, **GC의 발전 흐름이 Throughput 중심 -> Latency 중심으로 이동한 첫 전환점**이었다.

## 3. 작동 방식
CMS는 Generational GC 모델을 사용한다.
- Young Generation : ParNew GC 사용(Copying 기반 병렬 Young GC)
- Old Generation : CMS 사용

### Minor GC
- Young 영역은 ParNew가 수행하며, 여러 스레드가 병렬로 객체를 복사(Copying)한다. 
- ParNew는 Parallel Scavenge와는 다른 별도의 구현체로, CMS와 함께 사용되도록 설계되었다.

### Major GC

| **단계**                 | **동시 여부** | **설명**                                                                   |
|------------------------|-----------|--------------------------------------------------------------------------| 
| 1) Initial Mark        | X(STW)    | GC Root에서 직접 참조하는 Old 객체를 Mark. 매우 짧은 STW.                               |
| 2) Concurrent Mark     | O         | 애플리케이션이 실행하는 동안, Initial Mark에서 표시된 객체를 기준으로 객체 그래프를 따라가며 살아있는 객체를 Mark. |
| 3) Concurrent Preclean | O         | 애플리케이션이 실행 중 변경된 참조를 보정. <br/>Write Barrier를 이용해 Dirty Card를 추적하여 반영함.   |
| 4) Remark              | X(STW)    | Preclean 이후 남은 Dirty Card를 반영하여 최종 Mark를 완료함.                            |
| 5) Concurrent Sweep    | O         | 죽은 객체를 실제로 해제하고, 빈 공간을 Free List에 등록함. CMS는 Compaction을 수행하지 않음.         |
| 6) Concurrent Reset    | O         | 내부 Marking 자료구조를 초기화해 다음 사이클을 준비함. Free List는 유지됨.                       |

### ❓ Write Barrier란?
Write Barrier는 객체 참조가 변경될 때 JVM이 이를 감지해 GC 관련 메타데이터(Card Table 등)에 기록하는 메커니즘이다.
CMS 이를 이용해 Preclean과 Remark 단계에서 참조 변경분을 추적한다.

**동작과정**
<br>CMS에서 Write Barrier은 **Card Table + Dirty Bit** 방식으로 동작한다.

1. Old 영역을 작은 Card 단위(보통 512byte~2KB)로 나눈다.
2. 객체 참조가 변경될 때마다 JVM이 해당 Card를 "Dirty"로 표시한다.
3. GC는 Dirty Card를 기반으로 변경된 참조를 스캔하여 Mark 정보를 갱신한다.

## 4. 장단점

| **구분**        | **장점**                                         | **단점**                                            |
|---------------|------------------------------------------------|---------------------------------------------------|
| Latency       | STW 구간이 매우 짧음(Initial Mark + Remark 합쳐 수 ms 수준) | Concurrent 단계 중 CPU 사용량 증가로 애플리케이션 처리 지연될 가능성 존재  |
| Throughput    | 짧은 Pause 덕분에 응답 시간의 일관성이 높음                    | 전체 Throughput은 Parallel GC보다 낮음 (동시 실행 오버헤드 때문)   |
| Fragmentation | Compaction이 없어 GC 자체는 빠름                       | Fragmentation이 발생 가능성 존재 -> 심하면 Full GC 전환 가능성 존재 |
| CPU 사용        | 멀티코어 활용 효율이 높음             | 단일 코어 환경에서는 스케줄링 경쟁으로 인해 성능 저하 가능성 존재             |
| 안정성/예측성       | Low latency 환경(서버, 웹 요청)에 유리                   | Fragmentation 누적으로 예기치 못한 Full GC 발생 가능함          |


### ❓ Concurrent Mode Failure이란?
Concurrent 단계(특히 Mark 또는 Sweep) 도중 Old 영역의 여유 공간이 부족하여 새 객체를 위한 연속된 공간을 확보하지 못한 경우 발생한다.
<br>GC는 객체를 항상 연속된 메모리 블록에 할당해야 하는데, 조각이 많으면 전체 여유 공간이 충분해도 "붙어 있는" 빈 공간이 없어서 새 객체를 못 넣는 상황이 발생한다.
<br>이때 JVM이 STW Full GC(Mark-Compact)를 강제로 수행하며, 수백 ms ~ 수 초의 멈춤이 생긴다.
<br>CMS의 가장 큰 리스크이며, G1 GC가 CMS를 대체한 주요 이유 중 하나이다.

## 5. 언제 쓰면 좋을까?

## 적합
- Low latency가 중요한 서버(금융거래, 검색엔진 등)
- CPU 코어가 충분한 서버(4 코어 이상)
- Throughput보다 응답시간이 KPI인 서비스

## 비적합
- 단일코어 또는 CPU 여유가 부족한 서버
- 배치, ETL 등 Throughput이 중요한 시스템
- 대형 힙 (튜닝 없이는 Fragmentation 위험)

### ❓ 대형 힙일수록 Fragmentation이 왜 더 자주 발생할까?
**1. 객체 크기가 다양해짐**
<br>힙이 커질수록 할당되는 객체 크기도 다양해짐 (수 KB ~ 수 MB)
<br>이로 인해 다양한 크기의 빈 공간이 여러 곳에 흩어지게 되어 Free List 관리가 복잡해지고, 연속된 공간 확보가 어려워진다.

**2. Sweep 비용 증가**
<br>대형 힙일수록 죽은 객체가 흩어져 있는 위치를 탐색하는데 시간이 오래 걸린다. 
<br>그래서 Concurrent Sweep 단계 시간이 길어져, 이 단계가 끝나기 전에 Old 영역이 다시 차버릴 수 있다.
<br>결과적으로 Concurrent Mode Failure가 발생한다. 

**3. Fragmentation 누적**
<br>CMS는 Compaction을 수행하지 않기 떄문에, 시간이 지날수록 작은 빈 블록이 계속 누적된다.
<br>그 결과, 전체 여유 공간은 충분해도 연속된 큰 블록이 부족해 새 객체를 할당하지 못하고, STW Full GC로 전환될 수 있다.

### CMS가 효율적으로 동작하는 힙 크기

| **크기**            | **적합성** | **이유**                                                       |
|-------------------|---------|--------------------------------------------------------------|
| ~4GB        | X       | GC 빈도 높고 동시 수행의 이점이 적음. Parallel GC가 더 효율적.                  |
| 4GB ~ 16GB | O       | 짧은 STW와 적당한 Fragmentation 관리 가능. CPU 코어 4개 이상 권장.            |
| 16GB ~ 32GB  | 주의 필요   | Fragmentation 및 Concurrent Sweep 지연 가능성 증가                   |
| 32GB 이상    | X       | 튜닝(CMSInitiatingOccupancyFraction 등) 없이는 Full GC 발생할 가능성 높음. |

## 6. 결론

CMS GC는 Old 영역을 애플리케이션 스레드와 병행하여 Mark-Sweep 방식으로 정리하는 GC이다. 
<br>짧은 STW시간 덕분에 응답성이 중요한 시스템에 적합하지만, Fragmentation, 높은 CPU 부하, 복잡한 튜닝이 단점이다.
<br>이 한계를 개선하기 위해 G1 GC가 CMS를 대체하게 되었다.
